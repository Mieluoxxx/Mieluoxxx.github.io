<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>真真夜夜の研究所</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-19T05:48:35.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Moguw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac日常使用踩坑记</title>
    <link href="http://example.com/2022/10/19/Mac%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>http://example.com/2022/10/19/Mac%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0/</id>
    <published>2022-10-19T05:48:35.000Z</published>
    <updated>2022-10-19T05:48:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2022-10-19"><a href="#2022-10-19" class="headerlink" title="2022.10.19"></a>2022.10.19</h2><ol><li>破解软件绕过签名的办法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -rd com.apple.quarantine /Applications/xxxxxx.app</span><br></pre></td></tr></table></figure></li><li>mac终端在粘贴时有多余字符：00~  ~01之类的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;\e[?2004l&#x27;</span></span><br></pre></td></tr></table></figure></li><li>Mac 终端滚轮不滚页面，而是滚历史命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tput rmcup</span><br></pre></td></tr></table></figure></li><li>mac安装homebrew<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span> speed</span><br></pre></td></tr></table></figure></li><li>mac卸载homebrew<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2022-10-19&quot;&gt;&lt;a href=&quot;#2022-10-19&quot; class=&quot;headerlink&quot; title=&quot;2022.10.19&quot;&gt;&lt;/a&gt;2022.10.19&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;破解软件绕过签名的办法&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="Mac" scheme="http://example.com/categories/Mac/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac配置vscode的C/C++调试环境（vscode版）</title>
    <link href="http://example.com/2022/10/14/Mac%E9%85%8D%E7%BD%AEvscode%E7%9A%84C%E4%B8%8ECpp%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2022/10/14/Mac%E9%85%8D%E7%BD%AEvscode%E7%9A%84C%E4%B8%8ECpp%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</id>
    <published>2022-10-14T13:02:24.000Z</published>
    <updated>2022-10-14T13:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac配置vscode的C-x2F-C-调试环境"><a href="#Mac配置vscode的C-x2F-C-调试环境" class="headerlink" title="Mac配置vscode的C&#x2F;C++调试环境"></a>Mac配置vscode的C&#x2F;C++调试环境</h1><ul><li>新建一个文件夹，用vscode，然后再新建一个test.c文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>关键在于c_cpp_properties.json、tasks.json、launch.json这三个文件</p><h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>按下<code>fn + F1</code>键，打开<strong>命令面板</strong>，然后搜c&#x2F;c++<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015014631.png"><br>点击编辑配置UI<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015014740.png"><br>本文以clang++为例子，大家可以选择其他</p><h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><p>再次打开命令面板，然后搜Tasks<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015014911.png"><br>选择配置默认<strong>生成</strong>任务。<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015015039.png"><br>之后选择clang++，因为前文我们选择编译器路径是clang++</p><h1 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h1><p><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015015311.png"></p><p><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015015249.png"></p><p>我们选择c++（GDB&#x2F;LLDB）<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015015425.png"></p><p>打个断点，点击运行和调试，就发现可以调试了。<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221015015545.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mac配置vscode的C-x2F-C-调试环境&quot;&gt;&lt;a href=&quot;#Mac配置vscode的C-x2F-C-调试环境&quot; class=&quot;headerlink&quot; title=&quot;Mac配置vscode的C&amp;#x2F;C++调试环境&quot;&gt;&lt;/a&gt;Mac配置vscode的</summary>
      
    
    
    
    <category term="Mac" scheme="http://example.com/categories/Mac/"/>
    
    
    <category term="环境配置" scheme="http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形</title>
    <link href="http://example.com/2022/10/14/Z-GCNETs%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E7%9A%84%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E4%B9%8B%E5%AD%97%E5%BD%A2/"/>
    <id>http://example.com/2022/10/14/Z-GCNETs%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E7%9A%84%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E4%B9%8B%E5%AD%97%E5%BD%A2/</id>
    <published>2022-10-14T08:10:06.000Z</published>
    <updated>2022-10-14T08:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形"><a href="#Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形" class="headerlink" title="Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形"></a>Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>最近，人们对开发一类新的深度学习 (DL) 架构的兴趣激增，该架构<strong>将明确的时间维度集成为学习和表示机制的基本构建块</strong>。反过来，最近的许多结果表明，数据的持久同源性可能包含重要的互补信息，可以提高性能、增强 DL 的鲁棒性。作为这两个新兴想法的融合，我们提议使用最显着的数据的时间条件拓扑信息来增强 DL 架构，并将 zigzag 持久性的概念引入时间感知图卷积网络 (GCN)。 Zigzag 持久性提供了一个系统且数学上严谨的框架来跟踪观察到的数据的最重要的拓扑特征，这些拓扑特征往往会随着时间的推移而显现出来。为了将提取的时间条件拓扑描述集成到 DL 中，我们开发了一种新的拓扑总结，即锯齿形持久性图像（ZPI），并推导出其理论稳定性保证。我们使用时间感知之字形拓扑层 (Z-GCNETs) 验证新的 GCN，应用于流量预测和以太坊区块链价格预测。我们的结果表明 Z-GCNET 在 4 个时间序列数据集上优于 13 种最先进的方法</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在过去的几年中，我们观察到将深度神经网络架构与学习对象的持久同源表示的集成，通常以 DL 中某些拓扑层的形式。这种持久同源性表示允许我们提取和学习对象形状的描述。（通过这里的形状，我们广泛理解在连续变换（如弯曲、拉伸和压缩）下不变的数据特征）</p><p>在这里，我们迈出了融合这两个方向的第一步。为了使动态链表具有最显著的时态拓扑信息，我们将之字形持久化的概念引入到时态链表中。在箭图表示的基本结果的基础上，Zigzag 持久性研究了通过<strong>双向包含连接的拓扑空间的性质</strong>。我们建议将提取的时间感知持久性以 Zigzag 持久性图像的形式进行总结，然后将所得到的信息作为可学习的时间感知 Zigzag 层集成到GCN中。</p><h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ol><li>这是第一种将<strong>时间条件DL</strong>与<strong>数据的时间感知持久同调表示</strong>联系起来的方法。</li><li>提出了Zigzag持久化图像，并讨论了它的理论稳定性</li><li>将时间感知 Zigzag 持久性的概念引入学习时间条件图结构，提出了时间感知图卷积网络的之字形拓扑层(Z-GCNET)</li><li>将Z-GCNET应用于流量预测和以太区块链价格预测的实验表明，Z-GCNET在4个基准数据集上的准确率和稳健性都超过了13种最先进的方法。</li></ol><h2 id="Time-Aware-Topological-Signatures-of-Graphs"><a href="#Time-Aware-Topological-Signatures-of-Graphs" class="headerlink" title="Time-Aware Topological Signatures of Graphs"></a>Time-Aware Topological Signatures of Graphs</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><h4 id="Time-Aware-Zigzag-Persistence"><a href="#Time-Aware-Zigzag-Persistence" class="headerlink" title="Time-Aware Zigzag Persistence"></a>Time-Aware Zigzag Persistence</h4><p>由于我们的主要目标是评估多个时间条件对象的相互关联的演化，Zigzag 持久性是提出的持久同源性的概括，并提供了一个系统且数学上严格的框架来跟踪随时间持续存在的数据的最重要的拓扑特征。</p><p>令 {Gt}T1 是随时间观察到的一系列网络。 zigzag 持久性的关键思想是在这个时间有序的网络序列中评估成对兼容的拓扑特征。首先，我们定义了一组网络，包括令 ${Gt}<em>T^1$ 是随时间观察到的一系列网络。 zigzag 持久性的关键思想是在这个时间有序的网络序列中评估成对兼容的拓扑特征。<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221020013417.png"><br>其中 $G_k ∪ G</em>{k+1}$ 定义为具有节点集 $V_k ∪ V_{k+1}$ 和边集 $E_k ∪ E_{k+1}$ 的图。其次，我们固定一个尺度参数 $ν∗$ 并为给定的 $ν∗$ 在构建的网络包含集上构建单纯复形的锯齿形图。<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221020013732.png"><br>使用给定 $ν∗$ 的 zigzag 过滤，我们可以分别在时间点 $t_b$ 和 $t_d$，$1 ≤ t_b ≤ t_d ≤ T$ 跟踪 ${Gt}_T^1$ 上每个拓扑特征的出生和死亡。与非动态情况类似，我们可以扩展持久性图的概念，以分析由之字形持久性传递的时变数据的拓扑特征。</p><h4 id="Zigzag-Persistence-Diagram-ZPD"><a href="#Zigzag-Persistence-Diagram-ZPD" class="headerlink" title="Zigzag Persistence Diagram (ZPD)"></a>Zigzag Persistence Diagram (ZPD)</h4><p>当一个拓扑特征在固定尺度参数 $v∗$ 的单纯复形之字形图上的时间周期 $[1,T]$ 内首次出现 $t_b$ (即诞生)和消失 $t_d$ (即死亡)时，如果拓扑特征首先出现在$C(G_k，v*)$中，$t_b&#x3D;k$；如果它首先出现在 $C(Gk∪Gk+1，v*)$ 中，$t_b&#x3D;k+1&#x2F;2$。类似地，如果一个拓扑特征最后出现在 $C(G_k，v*)$ 中，$t_d&#x3D;k$；如果它最后出现在 $C(Gk∪Gk+1，v*)$中，$t_d&#x3D;k+1&#x2F;2$。对于固定的 $v*$，$R^2$中的多个点，$DgmZZ_{v*}&#x3D;\lbrace (t_b，t_d)∈R^2|t_b&lt;t_d \rbrace$ 称为ZPD图。</p><p>受持久化图像作为普通持久化的总结的概念的启发，为了将ZPD总结的拓扑信息输入GCN，我们提出了ZPD的ZPI表示。ZPI是ZPD的有限维矢量表示，可以通过以下步骤计算：</p><ol><li>将一个Z字形持久性图 $DgmZZ_{v∗}$ 映射到一个可积函数 $\rho DgmZZ_{v*}：R^2 \rightarrow R^2$，称为 zigzag 持久面。zigzag 持久面由以 $DgmZZ_{v*}$中每个点为中心的加权高斯函数之和给出，即 $DgmZZ_ν*$<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221016013800.png"></li><li>对网格中 zigzag 持久表面 $ρDgmZZ_{ν∗}$ 的子域进行离散化。</li><li>ZPI，即像素值矩阵，可以通过对每个网格框的后续积分获得。</li></ol><p>然后将 ZPI 内的每个像素 $z ∈ R2$ 的值定义为：<br><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221016014047.png"></p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221020012613.png"><br>给定一个滑动窗口，例如($G_{t−3}, . . . , G_t$)，我们基于 zigzag 过滤提取 ZPI。对于形状为 p × p 的 ZPI ∈ $R^2$，Z-GCNETs 首先通过基于 CNN 的框架学习 ZPI 的拓扑特征，然后应用全局最大池化来获得池化激活图中的最大值。 zigzag 持久表示学习的输出被解码为空间图卷积和时间图卷积，其中空间图卷积和时间图卷积的输入是当前时间戳，例如红色虚线框中的 Gt 和滑动窗口（即 ($G_{t−3}, . . . , G_t$) 分别在黄色虚线框中）。在图卷积操作之后，来自时间感知之字形拓扑层的特征被组合并移动到 GRU 进行预测。符号⊗代表点积，⊕代表组合。</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>我们考虑两种类型的网络（i）交通网络和（ii）以太坊令牌网络。</p><p>在交通网络中，节点由环路检测器表示，环路检测器可以实时检测交通状况，边缘是两个最近节点之间的高速公路路段。因此，节点集 Vt 和交通网络的节点特征矩阵 $X_t ∈ R^{N ×3}$ 表示每个节点在时间 t 有 3 个特征（即流速、速度和占用率）。为了捕捉空间和时间依赖，我们在时间 t 重建交通图结构 $Gt &#x3D; \lbrace V, Et, W^{ν∗}<em>t \rbrace$。<img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221020010856.png"><br>$w</em>{t,uv} &#x3D; e^{−||xt,u−xt,v ||2&#x2F;γ}$基于径向基函数 (RBF），为了研究交通图结构如何随时间演变，在每个时间点 t，我们只保留权重为 $ω^{ν∗}_t,uv$ 的边，它们不大于某个正阈值 $ν∗$。因此，结果图是动态的，也就是说，它的边集在所考虑的时间段内发生变化。</p><p>以太坊的代币网络平均有 442788&#x2F;1192722 个节点&#x2F;边。为了保持合理的计算时间，我们通过的最大权重子图近似方法获得一个子图，这使我们能够减少动态网络的大小，只考虑最活跃的节点和它的对应节点。让 $Gt &#x3D; {Vt, Et, \widetilde{W_t}}$ 表示第 t 天的缩小的以太坊区块链网络，$X_t∈R^{N_t×1}$是<strong>节点特征矩阵</strong>，我们假设只有一个节点特征：<strong>节点度</strong>。$V_t$ 中的每个节点是买方&#x2F;卖方，$E_t$ 中的边代表网络中的交易。为了构建相似性矩阵 $\widetilde{W_t}$，节点对（u，v）之间的归一化交易数量作为边缘权重值 $w_t$，$uv∈\widetilde {W_t}$。在我们的实验中，我们考虑的是整个时间段内100个最活跃的交易节点的集合。也就是说，<strong>在每个特定的日子t，节点和边的集合都是不同的</strong>。如果一个特定的节点 $v_i$ 在第 $t$ 天没有交易，那么 $v_i$ 就被记为孤立的节点。因此，$N&#x3D;100$。</p><h3 id="现有方法对比"><a href="#现有方法对比" class="headerlink" title="现有方法对比"></a>现有方法对比</h3><p><img src="https://markdown-1308430375.cos.ap-nanjing.myqcloud.com/20221020013018.png"><br>代码开源：https: &#x2F;&#x2F;github.com&#x2F;Z-GCNETs&#x2F;Z-GCNETs.git.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形&quot;&gt;&lt;a href=&quot;#Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形&quot; class=&quot;headerlink&quot; title=&quot;Z-GCNETs：用于时间序列预测的图卷积网络中的时间之字形&quot;&gt;</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图生成模型" scheme="http://example.com/tags/%E5%9B%BE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>GTN:基于Transformer的图生成模型</title>
    <link href="http://example.com/2022/10/14/GTN-%E5%9F%BA%E4%BA%8ETransformer%E7%9A%84%E5%9B%BE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/10/14/GTN-%E5%9F%BA%E4%BA%8ETransformer%E7%9A%84%E5%9B%BE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-10-14T06:28:05.000Z</published>
    <updated>2022-10-14T06:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GTN-基于Transformer的图生成模型"><a href="#GTN-基于Transformer的图生成模型" class="headerlink" title="GTN-基于Transformer的图生成模型"></a>GTN-基于Transformer的图生成模型</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GTN-基于Transformer的图生成模型&quot;&gt;&lt;a href=&quot;#GTN-基于Transformer的图生成模型&quot; class=&quot;headerlink&quot; title=&quot;GTN-基于Transformer的图生成模型&quot;&gt;&lt;/a&gt;GTN-基于Transformer</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图生成" scheme="http://example.com/tags/%E5%9B%BE%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
</feed>
